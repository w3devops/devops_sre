<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 1 Day 1: Kubernetes Basics - DevOps/SRE Learning Portfolio</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .content {
            background: white;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .breadcrumb {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        h1, h2, h3 {
            color: #667eea;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 2rem;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .goal-box {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .task-list {
            list-style: none;
            padding: 0;
        }

        .task-list li {
            padding: 8px 0;
            border-bottom: 1px solid #e1e4e8;
        }

        .task-list li:before {
            content: "üìã";
            margin-right: 10px;
            color: #667eea;
        }

        .component-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .component-box h3 {
            color: #667eea;
            margin-top: 0;
        }

        .mermaid {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow-x: auto;
            max-width: 100%;
        }

        .mermaid svg {
            max-width: 100%;
            height: auto;
        }

        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 5px;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .nav-buttons {
            text-align: center;
            margin: 30px 0;
        }

        .flow-steps {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
        }

        .flow-steps li {
            counter-increment: step-counter;
            padding: 15px 0;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
            padding-left: 50px;
        }

        .flow-steps li:before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 15px;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .mermaid {
                padding: 10px;
                margin: 15px 0;
            }

            .mermaid svg {
                transform: scale(0.8);
                transform-origin: top left;
            }
        }

        @media (max-width: 480px) {
            .mermaid svg {
                transform: scale(0.6);
                transform-origin: top left;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üê≥ Week 1: Kubernetes, Docker, Networking, and Security</h1>
            <p>Day 1: Kubernetes Basics - Building a strong foundation</p>
        </div>

        <div class="breadcrumb">
            <a href="../../index.html">Home</a> > 
            <a href="../../documentation.html">Documentation</a> > 
            <a href="../README.html">Week 1</a> >
            Day 1: Kubernetes Basics
        </div>

        <div class="content">
            <h1>Day 1: Kubernetes Basics (6 hours)</h1>
            
            <div class="goal-box">
                <h3>üéØ Goal</h3>
                <p>Build a strong foundation in Kubernetes, Docker, scripting, and security basics.</p>
            </div>

            <h2>üìö Learning Objectives</h2>
            <ul class="task-list">
                <li>Learn: Kubernetes architecture (control plane, nodes, pods, services, deployments)</li>
                <li>Resources: Kubernetes docs (kubernetes.io), FreeCodeCamp Kubernetes course (freecodecamp.org)</li>
                <li>Practice: Install Minikube/Kind, deploy an Nginx pod using kubectl apply -f, expose it as a service, and access it</li>
                <li>Task: Document kubectl commands in your README</li>
            </ul>

            <h2>üèóÔ∏è Kubernetes Architecture</h2>
            <p>A Kubernetes cluster consists of two main types of components: the <strong>Control Plane</strong> and the <strong>Worker Nodes</strong>.</p>

            <div class="component-box">
                <h3>üéõÔ∏è Control Plane</h3>
                <p>The Control Plane is the brain of the cluster. It manages the overall state of the applications and the cluster itself. Its core components are:</p>
                
                <ul>
                    <li><strong>kube-apiserver:</strong> The entry point for all cluster communication. It exposes the Kubernetes API.</li>
                    <li><strong>etcd:</strong> A consistent and highly-available key-value store that acts as the single source of truth for all cluster data.</li>
                    <li><strong>kube-scheduler:</strong> Watches for newly created Pods and assigns them to a healthy Worker Node based on resource requirements and other constraints.</li>
                    <li><strong>kube-controller-manager:</strong> Runs various controller processes that regulate the state of the cluster, ensuring the current state matches the desired state.</li>
                    <li><strong>cloud-controller-manager:</strong> (Optional) Integrates with the underlying cloud provider's infrastructure for features like load balancers and storage.</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>üñ•Ô∏è Worker Nodes</h3>
                <p>Worker Nodes are the machines (virtual or physical) where your containerized applications run. Each worker node contains:</p>
                
                <ul>
                    <li><strong>kubelet:</strong> An agent that runs on each node. It communicates with the Control Plane to ensure containers are running in a Pod as specified.</li>
                    <li><strong>kube-proxy:</strong> A network proxy that runs on each node, maintaining network rules and enabling communication to your Pods from inside or outside the cluster.</li>
                    <li><strong>Container Runtime:</strong> The software responsible for running containers. Kubernetes supports runtimes like containerd and CRI-O (and formerly Docker).</li>
                </ul>
            </div>

            <h2>üìä Kubernetes Architecture Diagram</h2>
            
            <div class="mermaid">
                graph TB
                    subgraph "Control Plane"
                        API[API Server]
                        ETCD[etcd Store]
                        SCHED[Scheduler]
                        CM[Controller Manager]
                    end
                    
                    subgraph "Worker Node"
                        KUBELET[kubelet]
                        PROXY[kube-proxy]
                        RUNTIME[Container Runtime]
                        POD1[Pod 1]
                        POD2[Pod 2]
                    end
                    
                    %% Control Plane connections
                    API --> ETCD
                    API --> SCHED
                    API --> CM
                    
                    %% API Server to Worker Node
                    API -.->|API Calls| KUBELET
                    
                    %% Worker Node internal connections
                    KUBELET --> RUNTIME
                    RUNTIME --> POD1
                    RUNTIME --> POD2
                    
                    %% Network proxy connections
                    PROXY -.->|Network Rules| POD1
                    PROXY -.->|Network Rules| POD2
                    
                    %% Styling
                    classDef controlPlane fill:#e1f5fe,stroke:#01579b,stroke-width:2px
                    classDef workerNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
                    classDef pod fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px
                    
                    class API,ETCD,SCHED,CM controlPlane
                    class KUBELET,PROXY,RUNTIME workerNode
                    class POD1,POD2 pod
            </div>
            
            <div class="goal-box">
                <h4>üì± Mobile-Friendly Version</h4>
                <p>This simplified diagram shows the core Kubernetes architecture optimized for mobile viewing. The full diagram with multiple worker nodes is available on desktop.</p>
            </div>

            <h2>üîß Architecture Components Explained</h2>

            <div class="component-box">
                <h3>üéõÔ∏è Control Plane Components</h3>
                <ul>
                    <li><strong>kube-apiserver:</strong> Central API server that all components communicate with</li>
                    <li><strong>etcd:</strong> Distributed key-value store for cluster state</li>
                    <li><strong>kube-scheduler:</strong> Assigns pods to nodes based on constraints</li>
                    <li><strong>kube-controller-manager:</strong> Runs controllers for different resources</li>
                    <li><strong>cloud-controller-manager:</strong> Integrates with cloud provider APIs</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>üñ•Ô∏è Worker Node Components</h3>
                <ul>
                    <li><strong>kubelet:</strong> Primary node agent that manages pod lifecycle</li>
                    <li><strong>kube-proxy:</strong> Network proxy for pod-to-pod communication</li>
                    <li><strong>Container Runtime:</strong> Software that runs containers (containerd, CRI-O)</li>
                </ul>
            </div>

            <h2>üîÑ Communication Flow</h2>
            <ol class="flow-steps">
                <li><strong>API Server</strong> is the central hub for all cluster communication</li>
                <li><strong>etcd</strong> stores the cluster state and configuration</li>
                <li><strong>Scheduler</strong> watches for new pods and assigns them to nodes</li>
                <li><strong>kubelet</strong> on each node receives pod specifications and manages containers</li>
                <li><strong>kube-proxy</strong> handles networking between pods and services</li>
            </ol>

            <h2>üìù Daily Tasks</h2>
            <div class="goal-box">
                <h3>‚úÖ Today's Checklist</h3>
                <ul class="task-list">
                    <li>Install Minikube or Kind on your local machine</li>
                    <li>Deploy an Nginx pod using kubectl apply -f</li>
                    <li>Expose the pod as a service</li>
                    <li>Access the service from your browser</li>
                    <li>Document all kubectl commands used</li>
                    <li>Practice basic kubectl commands (get, describe, logs)</li>
                </ul>
            </div>

            <h2>üîß Installation Steps</h2>
            
            <div class="component-box">
                <h3>üöÄ Step 1: Install Prerequisites</h3>
                <p>First, update your system and install required packages:</p>
                <pre><code>sudo apt update
sudo apt install -y curl wget apt-transport-https ca-certificates gnupg lsb-release</code></pre>
                <p><strong>Expected Output:</strong> System packages will be updated and required dependencies installed.</p>
            </div>

            <div class="component-box">
                <h3>üì¶ Step 2: Install kubectl</h3>
                <p>Download and install the latest version of kubectl:</p>
                <pre><code>curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Client Version: v1.33.2
Kustomize Version: v5.6.0</code></pre>
            </div>

            <div class="component-box">
                <h3>üê≥ Step 3: Install Minikube</h3>
                <p>Download and install Minikube:</p>
                <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
minikube version</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>minikube version: v1.36.0
commit: f8f52f5de11fc6ad8244afac475e1d0f96841df1-dirty</code></pre>
            </div>

            <div class="component-box">
                <h3>üêã Step 4: Install Docker</h3>
                <p>Install Docker and configure user permissions:</p>
                <pre><code>sudo apt install -y docker.io
sudo usermod -aG docker $USER
newgrp docker</code></pre>
                <p><strong>Verify Docker Installation:</strong></p>
                <pre><code>docker --version
docker ps</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Docker version 27.5.1, build 27.5.1-0ubuntu3
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</code></pre>
            </div>

            <div class="component-box">
                <h3>üöÄ Step 5: Start Minikube Cluster</h3>
                <p>Start your local Kubernetes cluster:</p>
                <pre><code>minikube start --driver=docker</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>üòÑ  minikube v1.36.0 on Ubuntu 25.04
‚ú®  Using the docker driver based on user configuration
üìå  Using Docker driver with root privileges
üëç  Starting "minikube" primary control-plane node in "minikube" cluster
üöú  Pulling base image v0.0.47 ...
üíæ  Downloading Kubernetes v1.33.1 preload ...
    > preloaded-images-k8s-v18-v1...:  347.04 MiB / 347.04 MiB  100.00% 14.39 M
    > gcr.io/k8s-minikube/kicbase...:  502.26 MiB / 502.26 MiB  100.00% 9.31 Mi
üî•  Creating docker container (CPUs=2, Memory=3800MB) ...
üê≥  Preparing Kubernetes v1.33.1 on Docker 28.1.1 ...
    ‚ñ™ Generating certificates and keys ...
    ‚ñ™ Booting up control plane ...
    ‚ñ™ Configuring RBAC rules ...
üîó  Configuring bridge CNI (Container Networking Interface) ...
üîé  Verifying Kubernetes components...
    ‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</code></pre>
            </div>

            <div class="component-box">
                <h3>‚úÖ Step 6: Verify Installation</h3>
                <p>Verify that everything is working correctly:</p>
                <pre><code>kubectl cluster-info
kubectl get nodes
kubectl get pods --all-namespaces</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Kubernetes control plane is running at https://127.0.0.1:32768
CoreDNS is running at https://127.0.0.1:32768/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   2m    v1.33.1

NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE
kube-system   coredns-787d4945fb-2k4vx          1/1     Running   0          2m
kube-system   etcd-minikube                      1/1     Running   0          2m
kube-system   kube-apiserver-minikube            1/1     Running   0          2m
kube-system   kube-controller-manager-minikube   1/1     Running   0          2m
kube-system   kube-proxy-2k4vx                   1/1     Running   0          2m
kube-system   kube-scheduler-minikube            1/1     Running   0          2m
kube-system   storage-provisioner                1/1     Running   0          2m</code></pre>
            </div>

            <div class="goal-box">
                <h3>üéØ Next Steps</h3>
                <p>Now that you have a working Kubernetes cluster, you can:</p>
                <ul class="task-list">
                    <li>Deploy your first application</li>
                    <li>Explore kubectl commands</li>
                    <li>Learn about pods, services, and deployments</li>
                    <li>Practice with the Nginx example</li>
                </ul>
            </div>

            <h2>üéõÔ∏è Kubernetes Dashboard & Monitoring</h2>
            
            <div class="component-box">
                <h3>üìä Step 7: Access Kubernetes Dashboard</h3>
                <p>Launch the Kubernetes web dashboard for visual cluster management:</p>
                <pre><code>minikube dashboard</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>üîå  Enabling dashboard ...
    ‚ñ™ Using image docker.io/kubernetesui/dashboard:v2.7.0
    ‚ñ™ Using image docker.io/kubernetesui/metrics-scraper:v1.0.8
üí°  Some dashboard features require the metrics-server addon. To enable all features please run:

	minikube addons enable metrics-server

ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...

üéâ  Opening http://127.0.0.1:39373/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...
Opening in existing browser session.</code></pre>
                
                <div class="goal-box">
                    <h4>üí° Dashboard Features</h4>
                    <ul>
                        <li><strong>Cluster Overview:</strong> View all nodes, pods, and services</li>
                        <li><strong>Resource Management:</strong> Create, edit, and delete resources</li>
                        <li><strong>Logs & Shell:</strong> Access container logs and execute commands</li>
                        <li><strong>Metrics:</strong> View CPU, memory, and network usage (with metrics-server)</li>
                        <li><strong>Namespace Management:</strong> Organize and manage different environments</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>üìà Step 8: Enable Metrics Server</h3>
                <p>Enable the metrics-server addon for enhanced monitoring capabilities:</p>
                <pre><code>minikube addons enable metrics-server</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>üí°  metrics-server is an addon maintained by Kubernetes. For any concerns contact minikube on GitHub.
You can view the list of minikube maintainers at: https://github.com/kubernetes/minikube/blob/master/OWNERS
    ‚ñ™ Using image registry.k8s.io/metrics-server/metrics-server:v0.7.2
üåü  The 'metrics-server' addon is enabled</code></pre>
                
                <div class="goal-box">
                    <h4>üìä Metrics Server Benefits</h4>
                    <ul>
                        <li><strong>Resource Monitoring:</strong> Real-time CPU and memory usage</li>
                        <li><strong>HPA Support:</strong> Enable Horizontal Pod Autoscaler</li>
                        <li><strong>Dashboard Integration:</strong> Enhanced dashboard metrics</li>
                        <li><strong>Performance Insights:</strong> Identify resource bottlenecks</li>
                        <li><strong>Capacity Planning:</strong> Better resource allocation decisions</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>üîç Dashboard Navigation Tips</h3>
                <p>Once the dashboard opens in your browser:</p>
                <ul class="task-list">
                    <li><strong>Overview:</strong> Start with the cluster overview page</li>
                    <li><strong>Namespaces:</strong> Switch between different namespaces (default, kube-system)</li>
                    <li><strong>Workloads:</strong> View deployments, pods, and replica sets</li>
                    <li><strong>Services:</strong> Check networking and service configurations</li>
                    <li><strong>Storage:</strong> Monitor persistent volumes and claims</li>
                    <li><strong>Config & Storage:</strong> Manage ConfigMaps and Secrets</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>üõ†Ô∏è Useful Dashboard Commands</h3>
                <p>Additional commands for dashboard management:</p>

                <div class="goal-box">
                    <h4>üîç Dashboard Status Check</h4>
                    <pre><code># Check dashboard status and get the URL without opening browser
minikube dashboard --url</code></pre>
                    <p><strong>What it does:</strong> Returns the dashboard URL that you can open manually in your browser</p>
                    <p><strong>When to use:</strong> When you want to access the dashboard but prefer to open it yourself or share the URL</p>
                    <p><strong>Expected Output:</strong> <code>http://127.0.0.1:XXXXX/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</code></p>
                </div>

                <div class="goal-box">
                    <h4>üì¶ Addons Management</h4>
                    <pre><code># List all available addons
minikube addons list

# Enable ingress addon for load balancer support
minikube addons enable ingress

# Enable storage provisioner for persistent volumes
minikube addons enable storage-provisioner</code></pre>
                    <p><strong>What it does:</strong> Manages optional Kubernetes addons that extend cluster functionality</p>
                    <p><strong>Addons explained:</strong></p>
                    <ul>
                        <li><strong>ingress:</strong> Enables ingress controller for advanced routing and load balancing</li>
                        <li><strong>storage-provisioner:</strong> Automatically provisions persistent storage for applications</li>
                        <li><strong>metrics-server:</strong> Provides resource usage metrics (already covered earlier)</li>
                    </ul>
                    <p><strong>Expected Output:</strong> Confirmation that the addon was enabled successfully</p>
                </div>

                <div class="goal-box">
                    <h4>üåê Remote Dashboard Access</h4>
                    <pre><code># Access dashboard from remote machine on specific port
minikube dashboard --url --port=8080</code></pre>
                    <p><strong>What it does:</strong> Starts the dashboard proxy on a specific port for remote access</p>
                    <p><strong>When to use:</strong> When accessing the dashboard from a different machine or when port conflicts exist</p>
                    <p><strong>Security note:</strong> Only use this in trusted networks as it exposes the dashboard externally</p>
                    <p><strong>Expected Output:</strong> Dashboard accessible at <code>http://[minikube-ip]:8080</code></p>
                </div>

                <div class="goal-box">
                    <h4>üí° Pro Tips</h4>
                    <ul>
                        <li><strong>Dashboard persistence:</strong> The dashboard stays running until you stop it with Ctrl+C</li>
                        <li><strong>Multiple sessions:</strong> You can access the dashboard from multiple browser tabs</li>
                        <li><strong>Token authentication:</strong> Use the token from <code>kubectl describe secret</code> for secure access</li>
                        <li><strong>Resource monitoring:</strong> Enable metrics-server addon for CPU/memory graphs in the dashboard</li>
                    </ul>
                </div>
            </div>

            <h2>üöÄ Hands-On Practice: Deploy Nginx</h2>
            
            <div class="component-box">
                <h3>üìù Step 9: Create Nginx Pod</h3>
                <p>First, let's create a simple Nginx pod using a YAML manifest:</p>
                
                <h4>Create the YAML file:</h4>
                <pre><code># Create practice directory
mkdir -p practice

# Create nginx.yaml file
cat &gt; practice/nginx.yaml &lt;&lt; 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
EOF</code></pre>
                
                <h4>Apply the manifest:</h4>
                <pre><code>kubectl apply -f practice/nginx.yaml</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>pod/nginx created</code></pre>
            </div>

            <div class="component-box">
                <h3>‚úÖ Step 10: Verify Pod Status</h3>
                <p>Check that the pod is running successfully:</p>
                <pre><code>kubectl get pods</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          20s</code></pre>
                
                <div class="goal-box">
                    <h4>üéØ Understanding Pod Status</h4>
                    <ul>
                        <li><strong>READY:</strong> 1/1 means 1 container is ready out of 1 total</li>
                        <li><strong>STATUS:</strong> Running indicates the pod is active</li>
                        <li><strong>RESTARTS:</strong> 0 means no restarts occurred</li>
                        <li><strong>AGE:</strong> How long the pod has been running</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>üåê Step 11: Expose Pod as Service</h3>
                <p>Create a service to make the Nginx pod accessible:</p>
                <pre><code>kubectl expose pod nginx --port=80 --type=NodePort</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>service/nginx exposed</code></pre>
                
                <h4>Check service details:</h4>
                <pre><code>kubectl get svc</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        24m
nginx        NodePort    10.108.195.122   &lt;none&gt;        80:31393/TCP   20s</code></pre>
                
                <div class="goal-box">
                    <h4>üîç Service Types Explained</h4>
                    <ul>
                        <li><strong>ClusterIP:</strong> Internal cluster access only</li>
                        <li><strong>NodePort:</strong> External access via node IP and port</li>
                        <li><strong>LoadBalancer:</strong> Cloud provider load balancer</li>
                        <li><strong>ExternalName:</strong> DNS CNAME record</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>üåç Step 12: Access the Application</h3>
                <p>Get the Minikube IP and access your Nginx application:</p>
                
                <h4>Get Minikube IP:</h4>
                <pre><code>minikube ip</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>192.168.49.2</code></pre>
                
                <h4>Access the application:</h4>
                <pre><code>curl http://192.168.49.2:31393</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                
                <div class="goal-box">
                    <h4>üéâ Success Indicators</h4>
                    <ul>
                        <li><strong>‚úÖ Pod Running:</strong> Nginx container is active</li>
                        <li><strong>‚úÖ Service Created:</strong> NodePort service exposed</li>
                        <li><strong>‚úÖ External Access:</strong> Can access via Minikube IP</li>
                        <li><strong>‚úÖ Web Response:</strong> Nginx welcome page displayed</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>üîç Step 13: Explore kubectl Commands</h3>
                <p>Practice these essential kubectl commands:</p>
                <pre><code># Get detailed pod information
kubectl describe pod nginx

# View pod logs
kubectl logs nginx

# Get pod details in YAML format
kubectl get pod nginx -o yaml

# Execute command inside the pod
kubectl exec -it nginx -- /bin/bash

# Get service details
kubectl describe service nginx

# Delete the resources
kubectl delete service nginx
kubectl delete pod nginx</code></pre>
                
                <div class="goal-box">
                    <h4>üìö Learning Objectives Achieved</h4>
                    <ul>
                        <li><strong>‚úÖ Pod Creation:</strong> Deployed container using YAML</li>
                        <li><strong>‚úÖ Service Exposure:</strong> Made pod accessible externally</li>
                        <li><strong>‚úÖ Network Access:</strong> Accessed application via NodePort</li>
                        <li><strong>‚úÖ kubectl Practice:</strong> Used essential commands</li>
                        <li><strong>‚úÖ Resource Management:</strong> Created and managed Kubernetes resources</li>
                    </ul>
                </div>
            </div>

            <h2>üìö Resources</h2>
            <ul>
                <li><a href="https://kubernetes.io/docs/" target="_blank">Kubernetes Official Documentation</a></li>
                <li><a href="https://www.freecodecamp.org/news/learn-kubernetes-in-under-3-hours/" target="_blank">FreeCodeCamp Kubernetes Course</a></li>
                <li><a href="https://minikube.sigs.k8s.io/docs/" target="_blank">Minikube Documentation</a></li>
                <li><a href="https://kind.sigs.k8s.io/" target="_blank">Kind Documentation</a></li>
            </ul>

            <div class="nav-buttons">
                <a href="../../index.html" class="btn">‚Üê Back to Home</a>
                <a href="../../documentation.html" class="btn">‚Üê Back to Documentation</a>
                <a href="../README.html" class="btn">‚Üê Back to Week 1</a>
                <a href="../Day2/README.html" class="btn">Next: Day 2 - Deployments & Configuration ‚Üí</a>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid with mobile-friendly settings
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            securityLevel: 'loose',
            responsive: true
        });

        // Handle mobile viewport
        function adjustMermaidForMobile() {
            const mermaidDivs = document.querySelectorAll('.mermaid');
            mermaidDivs.forEach(div => {
                const svg = div.querySelector('svg');
                if (svg && window.innerWidth <= 768) {
                    svg.style.maxWidth = '100%';
                    svg.style.height = 'auto';
                }
            });
        }

        // Adjust on load and resize
        window.addEventListener('load', adjustMermaidForMobile);
        window.addEventListener('resize', adjustMermaidForMobile);
    </script>
</body>
</html> 