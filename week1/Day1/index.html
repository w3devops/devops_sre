<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 1 Day 1: Kubernetes Basics - DevOps/SRE Learning Portfolio</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .content {
            background: white;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .breadcrumb {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        h1, h2, h3 {
            color: #667eea;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 2rem;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .goal-box {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .task-list {
            list-style: none;
            padding: 0;
        }

        .task-list li {
            padding: 8px 0;
            border-bottom: 1px solid #e1e4e8;
        }

        .task-list li:before {
            content: "ğŸ“‹";
            margin-right: 10px;
            color: #667eea;
        }

        .component-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .component-box h3 {
            color: #667eea;
            margin-top: 0;
        }

        .mermaid {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow-x: auto;
            max-width: 100%;
        }

        .mermaid svg {
            max-width: 100%;
            height: auto;
        }

        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 5px;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .nav-buttons {
            text-align: center;
            margin: 30px 0;
        }

        .flow-steps {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
        }

        .flow-steps li {
            counter-increment: step-counter;
            padding: 15px 0;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
            padding-left: 50px;
        }

        .flow-steps li:before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 15px;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .mermaid {
                padding: 10px;
                margin: 15px 0;
            }

            .mermaid svg {
                transform: scale(0.8);
                transform-origin: top left;
            }
        }

        @media (max-width: 480px) {
            .mermaid svg {
                transform: scale(0.6);
                transform-origin: top left;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ³ Week 1: Kubernetes, Docker, Networking, and Security</h1>
            <p>Day 1: Kubernetes Basics - Building a strong foundation</p>
        </div>

        <div class="breadcrumb">
            <a href="../../index.html">Home</a> > 
            <a href="../../documentation.html">Documentation</a> > 
            <a href="../README.html">Week 1</a> >
            Day 1: Kubernetes Basics
        </div>

        <div class="content">
            <h1>Day 1: Kubernetes Basics (6 hours)</h1>
            
            <div class="goal-box">
                <h3>ğŸ¯ Goal</h3>
                <p>Build a strong foundation in Kubernetes, Docker, scripting, and security basics.</p>
            </div>

            <h2>ğŸ“š Learning Objectives</h2>
            <ul class="task-list">
                <li>Learn: Kubernetes architecture (control plane, nodes, pods, services, deployments)</li>
                <li>Resources: Kubernetes docs (kubernetes.io), FreeCodeCamp Kubernetes course (freecodecamp.org)</li>
                <li>Practice: Install Minikube/Kind, deploy an Nginx pod using kubectl apply -f, expose it as a service, and access it</li>
                <li>Task: Document kubectl commands in your README</li>
            </ul>

            <h2>ğŸ—ï¸ Kubernetes Architecture</h2>
            <p>A Kubernetes cluster consists of two main types of components: the <strong>Control Plane</strong> and the <strong>Worker Nodes</strong>.</p>

            <div class="component-box">
                <h3>ğŸ›ï¸ Control Plane</h3>
                <p>The Control Plane is the brain of the cluster. It manages the overall state of the applications and the cluster itself. Its core components are:</p>
                
                <ul>
                    <li><strong>kube-apiserver:</strong> The entry point for all cluster communication. It exposes the Kubernetes API.</li>
                    <li><strong>etcd:</strong> A consistent and highly-available key-value store that acts as the single source of truth for all cluster data.</li>
                    <li><strong>kube-scheduler:</strong> Watches for newly created Pods and assigns them to a healthy Worker Node based on resource requirements and other constraints.</li>
                    <li><strong>kube-controller-manager:</strong> Runs various controller processes that regulate the state of the cluster, ensuring the current state matches the desired state.</li>
                    <li><strong>cloud-controller-manager:</strong> (Optional) Integrates with the underlying cloud provider's infrastructure for features like load balancers and storage.</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>ğŸ–¥ï¸ Worker Nodes</h3>
                <p>Worker Nodes are the machines (virtual or physical) where your containerized applications run. Each worker node contains:</p>
                
                <ul>
                    <li><strong>kubelet:</strong> An agent that runs on each node. It communicates with the Control Plane to ensure containers are running in a Pod as specified.</li>
                    <li><strong>kube-proxy:</strong> A network proxy that runs on each node, maintaining network rules and enabling communication to your Pods from inside or outside the cluster.</li>
                    <li><strong>Container Runtime:</strong> The software responsible for running containers. Kubernetes supports runtimes like containerd and CRI-O (and formerly Docker).</li>
                </ul>
            </div>

            <h2>ğŸ“Š Kubernetes Architecture Diagram</h2>
            
            <div class="mermaid">
                graph TB
                    subgraph "Control Plane"
                        API[API Server]
                        ETCD[etcd Store]
                        SCHED[Scheduler]
                        CM[Controller Manager]
                    end
                    
                    subgraph "Worker Node"
                        KUBELET[kubelet]
                        PROXY[kube-proxy]
                        RUNTIME[Container Runtime]
                        POD1[Pod 1]
                        POD2[Pod 2]
                    end
                    
                    %% Control Plane connections
                    API --> ETCD
                    API --> SCHED
                    API --> CM
                    
                    %% API Server to Worker Node
                    API -.->|API Calls| KUBELET
                    
                    %% Worker Node internal connections
                    KUBELET --> RUNTIME
                    RUNTIME --> POD1
                    RUNTIME --> POD2
                    
                    %% Network proxy connections
                    PROXY -.->|Network Rules| POD1
                    PROXY -.->|Network Rules| POD2
                    
                    %% Styling
                    classDef controlPlane fill:#e1f5fe,stroke:#01579b,stroke-width:2px
                    classDef workerNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
                    classDef pod fill:#e8f5e8,stroke:#2e7d32,stroke-width:1px
                    
                    class API,ETCD,SCHED,CM controlPlane
                    class KUBELET,PROXY,RUNTIME workerNode
                    class POD1,POD2 pod
            </div>
            
            <div class="goal-box">
                <h4>ğŸ“± Mobile-Friendly Version</h4>
                <p>This simplified diagram shows the core Kubernetes architecture optimized for mobile viewing. The full diagram with multiple worker nodes is available on desktop.</p>
            </div>

            <h2>ğŸ”§ Architecture Components Explained</h2>

            <div class="component-box">
                <h3>ğŸ›ï¸ Control Plane Components</h3>
                <ul>
                    <li><strong>kube-apiserver:</strong> Central API server that all components communicate with</li>
                    <li><strong>etcd:</strong> Distributed key-value store for cluster state</li>
                    <li><strong>kube-scheduler:</strong> Assigns pods to nodes based on constraints</li>
                    <li><strong>kube-controller-manager:</strong> Runs controllers for different resources</li>
                    <li><strong>cloud-controller-manager:</strong> Integrates with cloud provider APIs</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>ğŸ–¥ï¸ Worker Node Components</h3>
                <ul>
                    <li><strong>kubelet:</strong> Primary node agent that manages pod lifecycle</li>
                    <li><strong>kube-proxy:</strong> Network proxy for pod-to-pod communication</li>
                    <li><strong>Container Runtime:</strong> Software that runs containers (containerd, CRI-O)</li>
                </ul>
            </div>

            <h2>ğŸ”„ Communication Flow</h2>
            <ol class="flow-steps">
                <li><strong>API Server</strong> is the central hub for all cluster communication</li>
                <li><strong>etcd</strong> stores the cluster state and configuration</li>
                <li><strong>Scheduler</strong> watches for new pods and assigns them to nodes</li>
                <li><strong>kubelet</strong> on each node receives pod specifications and manages containers</li>
                <li><strong>kube-proxy</strong> handles networking between pods and services</li>
            </ol>

            <h2>ğŸ“ Daily Tasks</h2>
            <div class="goal-box">
                <h3>âœ… Today's Checklist</h3>
                <ul class="task-list">
                    <li>Install Minikube or Kind on your local machine</li>
                    <li>Deploy an Nginx pod using kubectl apply -f</li>
                    <li>Expose the pod as a service</li>
                    <li>Access the service from your browser</li>
                    <li>Document all kubectl commands used</li>
                    <li>Practice basic kubectl commands (get, describe, logs)</li>
                </ul>
            </div>

            <h2>ğŸ”§ Installation Steps</h2>
            
            <div class="component-box">
                <h3>ğŸš€ Step 1: Install Prerequisites</h3>
                <p>First, update your system and install required packages:</p>
                <pre><code>sudo apt update
sudo apt install -y curl wget apt-transport-https ca-certificates gnupg lsb-release</code></pre>
                <p><strong>Expected Output:</strong> System packages will be updated and required dependencies installed.</p>
            </div>

            <div class="component-box">
                <h3>ğŸ“¦ Step 2: Install kubectl</h3>
                <p>Download and install the latest version of kubectl:</p>
                <pre><code>curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Client Version: v1.33.2
Kustomize Version: v5.6.0</code></pre>
            </div>

            <div class="component-box">
                <h3>ğŸ³ Step 3: Install Minikube</h3>
                <p>Download and install Minikube:</p>
                <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
minikube version</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>minikube version: v1.36.0
commit: f8f52f5de11fc6ad8244afac475e1d0f96841df1-dirty</code></pre>
            </div>

            <div class="component-box">
                <h3>ğŸ‹ Step 4: Install Docker</h3>
                <p>Install Docker and configure user permissions:</p>
                <pre><code>sudo apt install -y docker.io
sudo usermod -aG docker $USER
newgrp docker</code></pre>
                <p><strong>Verify Docker Installation:</strong></p>
                <pre><code>docker --version
docker ps</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Docker version 27.5.1, build 27.5.1-0ubuntu3
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</code></pre>
            </div>

            <div class="component-box">
                <h3>ğŸš€ Step 5: Start Minikube Cluster</h3>
                <p>Start your local Kubernetes cluster:</p>
                <pre><code>minikube start --driver=docker</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>ğŸ˜„  minikube v1.36.0 on Ubuntu 25.04
âœ¨  Using the docker driver based on user configuration
ğŸ“Œ  Using Docker driver with root privileges
ğŸ‘  Starting "minikube" primary control-plane node in "minikube" cluster
ğŸšœ  Pulling base image v0.0.47 ...
ğŸ’¾  Downloading Kubernetes v1.33.1 preload ...
    > preloaded-images-k8s-v18-v1...:  347.04 MiB / 347.04 MiB  100.00% 14.39 M
    > gcr.io/k8s-minikube/kicbase...:  502.26 MiB / 502.26 MiB  100.00% 9.31 Mi
ğŸ”¥  Creating docker container (CPUs=2, Memory=3800MB) ...
ğŸ³  Preparing Kubernetes v1.33.1 on Docker 28.1.1 ...
    â–ª Generating certificates and keys ...
    â–ª Booting up control plane ...
    â–ª Configuring RBAC rules ...
ğŸ”—  Configuring bridge CNI (Container Networking Interface) ...
ğŸ”  Verifying Kubernetes components...
    â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</code></pre>
            </div>

            <div class="component-box">
                <h3>âœ… Step 6: Verify Installation</h3>
                <p>Verify that everything is working correctly:</p>
                <pre><code>kubectl cluster-info
kubectl get nodes
kubectl get pods --all-namespaces</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>Kubernetes control plane is running at https://127.0.0.1:32768
CoreDNS is running at https://127.0.0.1:32768/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   2m    v1.33.1

NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE
kube-system   coredns-787d4945fb-2k4vx          1/1     Running   0          2m
kube-system   etcd-minikube                      1/1     Running   0          2m
kube-system   kube-apiserver-minikube            1/1     Running   0          2m
kube-system   kube-controller-manager-minikube   1/1     Running   0          2m
kube-system   kube-proxy-2k4vx                   1/1     Running   0          2m
kube-system   kube-scheduler-minikube            1/1     Running   0          2m
kube-system   storage-provisioner                1/1     Running   0          2m</code></pre>
            </div>

            <div class="goal-box">
                <h3>ğŸ¯ Next Steps</h3>
                <p>Now that you have a working Kubernetes cluster, you can:</p>
                <ul class="task-list">
                    <li>Deploy your first application</li>
                    <li>Explore kubectl commands</li>
                    <li>Learn about pods, services, and deployments</li>
                    <li>Practice with the Nginx example</li>
                </ul>
            </div>

            <h2>ğŸ›ï¸ Kubernetes Dashboard & Monitoring</h2>
            
            <div class="component-box">
                <h3>ğŸ“Š Step 7: Access Kubernetes Dashboard</h3>
                <p>Launch the Kubernetes web dashboard for visual cluster management:</p>
                <pre><code>minikube dashboard</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>ğŸ”Œ  Enabling dashboard ...
    â–ª Using image docker.io/kubernetesui/dashboard:v2.7.0
    â–ª Using image docker.io/kubernetesui/metrics-scraper:v1.0.8
ğŸ’¡  Some dashboard features require the metrics-server addon. To enable all features please run:

	minikube addons enable metrics-server

ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...

ğŸ‰  Opening http://127.0.0.1:39373/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...
Opening in existing browser session.</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ’¡ Dashboard Features</h4>
                    <ul>
                        <li><strong>Cluster Overview:</strong> View all nodes, pods, and services</li>
                        <li><strong>Resource Management:</strong> Create, edit, and delete resources</li>
                        <li><strong>Logs & Shell:</strong> Access container logs and execute commands</li>
                        <li><strong>Metrics:</strong> View CPU, memory, and network usage (with metrics-server)</li>
                        <li><strong>Namespace Management:</strong> Organize and manage different environments</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>ğŸ“ˆ Step 8: Enable Metrics Server</h3>
                <p>Enable the metrics-server addon for enhanced monitoring capabilities:</p>
                <pre><code>minikube addons enable metrics-server</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>ğŸ’¡  metrics-server is an addon maintained by Kubernetes. For any concerns contact minikube on GitHub.
You can view the list of minikube maintainers at: https://github.com/kubernetes/minikube/blob/master/OWNERS
    â–ª Using image registry.k8s.io/metrics-server/metrics-server:v0.7.2
ğŸŒŸ  The 'metrics-server' addon is enabled</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ“Š Metrics Server Benefits</h4>
                    <ul>
                        <li><strong>Resource Monitoring:</strong> Real-time CPU and memory usage</li>
                        <li><strong>HPA Support:</strong> Enable Horizontal Pod Autoscaler</li>
                        <li><strong>Dashboard Integration:</strong> Enhanced dashboard metrics</li>
                        <li><strong>Performance Insights:</strong> Identify resource bottlenecks</li>
                        <li><strong>Capacity Planning:</strong> Better resource allocation decisions</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>ğŸ” Dashboard Navigation Tips</h3>
                <p>Once the dashboard opens in your browser:</p>
                <ul class="task-list">
                    <li><strong>Overview:</strong> Start with the cluster overview page</li>
                    <li><strong>Namespaces:</strong> Switch between different namespaces (default, kube-system)</li>
                    <li><strong>Workloads:</strong> View deployments, pods, and replica sets</li>
                    <li><strong>Services:</strong> Check networking and service configurations</li>
                    <li><strong>Storage:</strong> Monitor persistent volumes and claims</li>
                    <li><strong>Config & Storage:</strong> Manage ConfigMaps and Secrets</li>
                </ul>
            </div>

            <div class="component-box">
                <h3>ğŸ› ï¸ Useful Dashboard Commands</h3>
                <p>Additional commands for dashboard management:</p>

                <div class="goal-box">
                    <h4>ğŸ” Dashboard Status Check</h4>
                    <pre><code># Check dashboard status and get the URL without opening browser
minikube dashboard --url</code></pre>
                    <p><strong>What it does:</strong> Returns the dashboard URL that you can open manually in your browser</p>
                    <p><strong>When to use:</strong> When you want to access the dashboard but prefer to open it yourself or share the URL</p>
                    <p><strong>Expected Output:</strong> <code>http://127.0.0.1:XXXXX/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</code></p>
                </div>

                <div class="goal-box">
                    <h4>ğŸ“¦ Addons Management</h4>
                    <pre><code># List all available addons
minikube addons list

# Enable ingress addon for load balancer support
minikube addons enable ingress

# Enable storage provisioner for persistent volumes
minikube addons enable storage-provisioner</code></pre>
                    <p><strong>What it does:</strong> Manages optional Kubernetes addons that extend cluster functionality</p>
                    <p><strong>Addons explained:</strong></p>
                    <ul>
                        <li><strong>ingress:</strong> Enables ingress controller for advanced routing and load balancing</li>
                        <li><strong>storage-provisioner:</strong> Automatically provisions persistent storage for applications</li>
                        <li><strong>metrics-server:</strong> Provides resource usage metrics (already covered earlier)</li>
                    </ul>
                    <p><strong>Expected Output:</strong> Confirmation that the addon was enabled successfully</p>
                </div>

                <div class="goal-box">
                    <h4>ğŸŒ Remote Dashboard Access</h4>
                    <pre><code># Access dashboard from remote machine on specific port
minikube dashboard --url --port=8080</code></pre>
                    <p><strong>What it does:</strong> Starts the dashboard proxy on a specific port for remote access</p>
                    <p><strong>When to use:</strong> When accessing the dashboard from a different machine or when port conflicts exist</p>
                    <p><strong>Security note:</strong> Only use this in trusted networks as it exposes the dashboard externally</p>
                    <p><strong>Expected Output:</strong> Dashboard accessible at <code>http://[minikube-ip]:8080</code></p>
                </div>

                <div class="goal-box">
                    <h4>ğŸ’¡ Pro Tips</h4>
                    <ul>
                        <li><strong>Dashboard persistence:</strong> The dashboard stays running until you stop it with Ctrl+C</li>
                        <li><strong>Multiple sessions:</strong> You can access the dashboard from multiple browser tabs</li>
                        <li><strong>Token authentication:</strong> Use the token from <code>kubectl describe secret</code> for secure access</li>
                        <li><strong>Resource monitoring:</strong> Enable metrics-server addon for CPU/memory graphs in the dashboard</li>
                    </ul>
                </div>
            </div>

            <h2>ğŸš€ Hands-On Practice: Deploy Nginx</h2>
            
            <div class="component-box">
                <h3>ğŸ“ Step 9: Create Nginx Pod</h3>
                <p>First, let's create a simple Nginx pod using a YAML manifest:</p>
                
                <h4>Create the YAML file:</h4>
                <pre><code># Create practice directory
mkdir -p practice

# Create nginx.yaml file
cat &gt; practice/nginx.yaml &lt;&lt; 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
EOF</code></pre>
                
                <h4>Apply the manifest:</h4>
                <pre><code>kubectl apply -f practice/nginx.yaml</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>pod/nginx created</code></pre>
            </div>

            <div class="component-box">
                <h3>âœ… Step 10: Verify Pod Status</h3>
                <p>Check that the pod is running successfully:</p>
                <pre><code>kubectl get pods</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          20s</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ¯ Understanding Pod Status</h4>
                    <ul>
                        <li><strong>READY:</strong> 1/1 means 1 container is ready out of 1 total</li>
                        <li><strong>STATUS:</strong> Running indicates the pod is active</li>
                        <li><strong>RESTARTS:</strong> 0 means no restarts occurred</li>
                        <li><strong>AGE:</strong> How long the pod has been running</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>ğŸŒ Step 11: Expose Pod as Service</h3>
                <p>Create a service to make the Nginx pod accessible:</p>
                <pre><code>kubectl expose pod nginx --port=80 --type=NodePort</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>service/nginx exposed</code></pre>
                
                <h4>Check service details:</h4>
                <pre><code>kubectl get svc</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        24m
nginx        NodePort    10.108.195.122   &lt;none&gt;        80:31393/TCP   20s</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ” Service Types Explained</h4>
                    <ul>
                        <li><strong>ClusterIP:</strong> Internal cluster access only</li>
                        <li><strong>NodePort:</strong> External access via node IP and port</li>
                        <li><strong>LoadBalancer:</strong> Cloud provider load balancer</li>
                        <li><strong>ExternalName:</strong> DNS CNAME record</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>ğŸŒ Step 12: Access the Application</h3>
                <p>Get the Minikube IP and access your Nginx application:</p>
                
                <h4>Get Minikube IP:</h4>
                <pre><code>minikube ip</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>192.168.49.2</code></pre>
                
                <h4>Access the application:</h4>
                <pre><code>curl http://192.168.49.2:31393</code></pre>
                <p><strong>Expected Output:</strong></p>
                <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ‰ Success Indicators</h4>
                    <ul>
                        <li><strong>âœ… Pod Running:</strong> Nginx container is active</li>
                        <li><strong>âœ… Service Created:</strong> NodePort service exposed</li>
                        <li><strong>âœ… External Access:</strong> Can access via Minikube IP</li>
                        <li><strong>âœ… Web Response:</strong> Nginx welcome page displayed</li>
                    </ul>
                </div>
            </div>

            <div class="component-box">
                <h3>ğŸ” Step 13: Explore kubectl Commands</h3>
                <p>Practice these essential kubectl commands:</p>
                <pre><code># Get detailed pod information
kubectl describe pod nginx

# View pod logs
kubectl logs nginx

# Get pod details in YAML format
kubectl get pod nginx -o yaml

# Execute command inside the pod
kubectl exec -it nginx -- /bin/bash

# Get service details
kubectl describe service nginx

# Delete the resources
kubectl delete service nginx
kubectl delete pod nginx</code></pre>
                
                <div class="goal-box">
                    <h4>ğŸ“š Learning Objectives Achieved</h4>
                    <ul>
                        <li><strong>âœ… Pod Creation:</strong> Deployed container using YAML</li>
                        <li><strong>âœ… Service Exposure:</strong> Made pod accessible externally</li>
                        <li><strong>âœ… Network Access:</strong> Accessed application via NodePort</li>
                        <li><strong>âœ… kubectl Practice:</strong> Used essential commands</li>
                        <li><strong>âœ… Resource Management:</strong> Created and managed Kubernetes resources</li>
                    </ul>
                </div>
            </div>

            <h2>ğŸ“š Resources</h2>
            <ul>
                <li><a href="https://kubernetes.io/docs/" target="_blank">Kubernetes Official Documentation</a></li>
                <li><a href="https://www.freecodecamp.org/news/learn-kubernetes-in-under-3-hours/" target="_blank">FreeCodeCamp Kubernetes Course</a></li>
                <li><a href="https://minikube.sigs.k8s.io/docs/" target="_blank">Minikube Documentation</a></li>
                <li><a href="https://kind.sigs.k8s.io/" target="_blank">Kind Documentation</a></li>
            </ul>

            <div class="nav-buttons">
                <a href="../../index.html" class="btn">â† Back to Home</a>
                <a href="../../documentation.html" class="btn">â† Back to Documentation</a>
                <a href="../README.html" class="btn">â† Back to Week 1</a>
                <a href="../Day2/README.html" class="btn">Next: Day 2 - Deployments & Configuration â†’</a>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid with mobile-friendly settings
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            securityLevel: 'loose',
            responsive: true
        });

        // Handle mobile viewport
        function adjustMermaidForMobile() {
            const mermaidDivs = document.querySelectorAll('.mermaid');
            mermaidDivs.forEach(div => {
                const svg = div.querySelector('svg');
                if (svg && window.innerWidth <= 768) {
                    svg.style.maxWidth = '100%';
                    svg.style.height = 'auto';
                }
            });
        }

        // Adjust on load and resize
        window.addEventListener('load', adjustMermaidForMobile);
        window.addEventListener('resize', adjustMermaidForMobile);
    </script>
</body>
</html> 